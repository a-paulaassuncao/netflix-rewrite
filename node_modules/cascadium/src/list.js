import {propFunc, propPath} from './prop-func';
import {Group} from './group';

export class List extends Array {
  constructor(...args) {
    super(...args);
  }

  last() {
    return this[this.length - 1];
  }

  orderBy(key) {

    if (key === undefined) {
      throw Error('List.orderBy: key not provided')
    }

    this.sort((prev, next) => {
      const prevVal = propFunc(prev, key),
            nextVal = propFunc(next, key);

      return prevVal > nextVal ? 1 : prevVal < nextVal ? -1 : 0
    })

    return this;
  }

  grip(key){

    const Container = this.constructor;

    let group = {};
  
    if (key === undefined) {
      throw Error('List.orderBy: key not provided')
    }  
  
    for (let i = 0; i < this.length; i++){
      const rec = this[i];
      const label = propFunc(rec, key);

      group[label] ??= new Container();
      group[label].push(rec);
    }

    return new Group(Container, group);
  }

  partition(num) {
    const newList = new this.constructor();
    for (let i = 0; i < this.length; i+=num) {
      newList.push(this.slice(i, i+num));
    }
    return newList;
  }

  one(propSpec, val) {
    for (let i = 0; i < this.length; i++) {
      if (propPath(this[i], propSpec) === val) {
        return this[i];
      }
    }
    return undefined;
  }

  all(propSpec, val) {
    const res = new this.constructor();
    for (let i = 0; i < this.length; i++) {
      if(propPath(this[i], propSpec) === val) {
        res.push(this[i])
      }
    }
    return res;
  }

  mergeFrom(sources, {sourceKey, targetKey, mergeKey, mergeFunc}={}) {

    if (!mergeKey && !sourceKey && !targetKey ) {
      throw Error ('mergeFrom: none of matchKey, partKey, and mergeKey specified');
    }

    if (!mergeFunc) {
      throw Error ('mergeFrom: mergeFunc must be specified');
    }

    const targetMap = {};

    const actualTargetKey = targetKey ?? mergeKey;
    const actualSourceKey = sourceKey ?? mergeKey;

    for (let targ = this.length - 1; targ >= 0; targ --) {
      const targElem = this[targ];
      const targKey = propFunc(targElem, actualTargetKey);
      targetMap[targKey] ??= targElem;
    }

    for (let sour = sources.length - 1; sour >= 0; sour --) {
      const sourElem = sources[sour];
      const sourKey = propFunc(sourElem, actualSourceKey);
      const targElem = targetMap[sourKey];
      targElem && mergeFunc({target:targElem, source:sourElem});
    }
  }

  insert(rec, index) {
    this.splice(index, 0, rec);
    return this;
  }

  remove(index) {
    this.splice(index, 1);
    return this;
  }

  moveBack(i) {
    if (i > 0) {
      [this[i], this[i-1]] = [this[i-1], this[i]];
    }
    return this;
  }

  moveFore(i) {
    if (i < this.length - 1) {
      [this[i], this[i+1]] = [this[i+1], this[i]];
    }
    return this;
  }

}
