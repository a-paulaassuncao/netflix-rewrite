import { expect } from '@jest/globals';
import {Cask} from './cask';
import {randomString, randomSelect, createEntry} from './test-utils';

const createFlatCask = ({attempts=100, successorProp='succ', nestProp='code'}={}) => {
  let counter = attempts;
  let cateList = new Cask();

  cateList.push(createEntry({
    props: {[nestProp]: ''},
    successorProp,
    successorCons:Cask
  }));

  while(counter > 0) {

    if (cateList.length === 0) {
      cateList.push(createEntry({
        props:{code: randomString(2)},
        successorProp,
        successorCons:Cask
      }));
    }
    const {[nestProp]: prop} = randomSelect(cateList);
    const newEntry = createEntry({
      props:{code: `${prop}${randomString(2)}`},
      successorProp,
      successorCons:Cask,
    });

    if (!cateList.map(({[nestProp]: prop}) => prop).includes(newEntry[nestProp])) {
      cateList.push(newEntry);
    }

    counter --;
  }

  cateList.shift()
  return cateList;
}

describe('nesting & unnesting & merging', () => {

  const geneFunc = rec => rec.code.length;

  const seekFunc = (pred, succ) => {
    const isMatching = succ.code.startsWith(pred.code);
    if (isMatching) {
      pred.succ ??= new Cask();
      pred.succ.push(succ);
    }
    return isMatching;
  };

  it('error nesting when geneFunc or seekFunc not specified', () => {

    let cask = createFlatCask();

    expect(() => cask.nest()).toThrow('geneFunc');
    expect(() => cask.nest(geneFunc)).toThrow('seekFunc');
    expect(() => cask.nest(undefined, seekFunc)).toThrow('geneFunc');
  
  })

  it('error unnesting when succFunc not given', () => {

    let cask = createFlatCask();

    expect(() => cask.nest(geneFunc, seekFunc).unnest()).toThrow('succFunc');  
  })

  it('the list after nesting & unnesting should be equal-lengthed with original', () => {
    
    const succFunc = rec => rec.succ;

    let cask = createFlatCask({attempts: 20});
    
    let unnested = cask.nest(geneFunc, seekFunc).unnest(succFunc);
    
    console.log(unnested);
    expect(unnested.length).toBe(cask.length);

    for (let i = 0; i < cask.length; i++) {
      expect(unnested.includes(cask[i])).toBe(true);
    }
  })
  
  it('unnesting with incompatible succFunc cause identical list', () => {

    const siccFunc = rec => rec.sicc;

    let nested = createFlatCask().nest(geneFunc, seekFunc);

    expect(nested.unnest(siccFunc).length).toBe(nested.length);
    expect(nested.unnest(siccFunc)).toEqual(nested);
  })
  
}) 
