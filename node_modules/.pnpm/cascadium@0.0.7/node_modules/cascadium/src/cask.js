import {List} from './list';

export class Cask extends List {
  constructor(...args){
    super(...args);
  }

  unnest(succFunc) {

    if (succFunc === undefined) {
      throw Error('Cask.unnest: succFunc must be defined for expanding childrens');
    }

    const stack = [...this];
    const res = new Cask();

    while(stack.length) {
      const next = stack.shift();
      const succ = succFunc(next);
      if(succ?.constructor === Cask && succ.length > 0) {
        stack.unshift(...succ);
      }
      res.push(next);
    }
    return res;
  }

  nest(geneFunc, seekFunc) {

    if (geneFunc === undefined) {
      throw Error('Cask.nest: geneFunc must be defined for partitioning generations');
    }

    if (seekFunc === undefined) {
      throw Error('Cask.nest: seekFunc must be defined for coupling parent and child');
    }

    // 将列表按照geneFunc指定的方式分代，所得到的结果
    const gens = this.orderBy(geneFunc)
      .grip(geneFunc)
      .grap();

    // 在每两代之间进行匹配，seekFunc中规定了匹配的依据及匹配的方法，
    // 由于一个子级元素只能归属于一个父级元素，因此一旦子级元素匹配到
    // 了一个父级元素，就应当立即停止遍历后续的父级元素，故seekFunc
    // 应当返回一个bool值来决定是否停止。
    // 
    // 至于匹配之后要如何进行关联（通常是将子层元素移入父层元素某个列
    // 表属性中），应当在seekFunc中作为一个sideEffect来实现，如果
    // 操作不成功应当抛出异常。
    
    for (let gene = gens.length - 2; gene >= 0; gene --) {

      const preds = gens[gene];
      const currs = gens[gene+1];
      
      for (let curr = currs.length - 1; curr >= 0; curr --)
      for (let pred = preds.length - 1; pred >= 0; pred --)
        if (seekFunc(preds[pred], currs[curr])) 
          break;
    }

    // 返回匹配完成的祖先一代。
    return gens[0];
  }
}