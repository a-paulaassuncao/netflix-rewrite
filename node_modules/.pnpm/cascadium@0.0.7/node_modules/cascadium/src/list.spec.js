import {List} from './list';
import {randomString, randomListIndex, createEntry} from './test-utils';

test('create', () => {
  const raw = [...Array(100)].map(() => randomString());
  const list = List.from(raw).map(name => ({prop:{name}}));

  expect(list instanceof List).toBe(true);
})

test('orderBy', () => {

  const raw = [...Array(100)].map(() => randomString());
  const list = List.from(raw).map(name => ({prop:{name}}));

  const rawNames = raw
    .slice()
    .sort((cPrev, cNext) => cPrev < cNext ? -1 : cPrev > cNext ? 1 : 0)

  expect(() => list.slice().orderBy()).toThrow('key');

  const listNamesPropPath = list.slice()
    .orderBy('prop.name')
    .map(({prop:{name}}) => name);

  const listNamesPropFunc = list.slice()
    .orderBy(({prop:{name}}) => name)
    .map(({prop:{name}}) => name);

  expect([...listNamesPropPath]).toEqual(rawNames);
  expect([...listNamesPropFunc]).toEqual(rawNames);
})

test('grip', () => {
  const raw = [...Array(10)].map(() => randomString(2))
    .map(name => [...Array(2)].map(() => `${name}/${randomString(20)}`))
    .flat()
    .map(code => ({code}));

  const list = List.from(raw);

  expect(() => list.grip()).toThrow('key');

  const grippedCode = list.grip('code');
  expect(grippedCode.cons).toBe(List);
  expect(grippedCode.keys().length).toBe(20);
  
  const grippedPrefix = list.grip(({code}) => code.split('/')[0]);
  expect(grippedPrefix.cons).toBe(List);
  expect(grippedPrefix.keys().length).toBe(10);
})

test('partition', () => {
  const raw = [...Array(100)].map(() => randomString());

  const list = List.from(raw);
  const partitioned = list.partition(7);
  expect(partitioned.length).toBe(15);
  expect(partitioned.last().length).toBe(2);
})

test('insert', () => {
  const newEntry = {};

  const list = List.from([...Array(100)].map((_, i) => ({i})));

  const index = randomListIndex(list);

  list.insert(newEntry, index);

  expect(list[index]).toBe(newEntry);

})

test('remove', () => {
  const list = List.from([...Array(100)].map((_, i) => ({i})));

  const index = randomListIndex(list);

  const elem = list[index];

  list.remove(index);

  expect(list).not.toContain(elem);
})

test('move-back', () => {
  const list = List.from([...Array(100)].map((_, i) => ({i})));

  const index = randomListIndex(list);

  const [prev, next] = [list[index - 1], list[index]];

  list.moveBack(index);

  expect(list[index]).toBe(prev)
  expect(list[index - 1]).toBe(next);

  let copy = list.slice();
  copy.moveBack(-1);
  expect(copy).toEqual(list);
})

test('move-fore', () => {
  const list = List.from([...Array(100)].map((_, i) => ({i})));

  const index = randomListIndex(list);

  const [prev, next] = [list[index], list[index + 1]];

  list.moveFore(index);

  expect(list[index + 1]).toBe(prev)
  expect(list[index]).toBe(next);

  let copy = list.slice();
  copy.moveFore(list.length + 1);
  expect(copy).toEqual(list);

})

test('merges from another list', () => {
  const IDs = [...Array(100)].map(() => randomString(100));
  const source = List.from(IDs.map(id => createEntry({props: {id, source:'source'}})));
  const target = List.from(IDs.map(id => createEntry({props: {id, target:'target'}})));

  const mergeFunc = ({target, source}) => {
    Object.assign(target, source)
  };

  expect(() => target.mergeFrom(source, {mergeKey: 'id'})).toThrow('mergeFunc');
  expect(() => target.mergeFrom(source, {mergeFunc})).toThrow('mergeKey');
  expect(() => target.mergeFrom(source)).toThrow('mergeKey');

  target.mergeFrom(source, {mergeFunc, mergeKey: 'id'});
})
