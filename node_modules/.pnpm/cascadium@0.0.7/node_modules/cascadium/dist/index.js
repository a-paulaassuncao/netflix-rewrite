module.exports =
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 981:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Cask": () => (/* reexport */ Cask),
  "List": () => (/* reexport */ List)
});

;// CONCATENATED MODULE: ./src/prop-func.js
const propPath = (rec, propPath) => {
  if (!propPath.includes('.')) {
    return rec[propPath];
  } else {
    const path = propPath.split('.').reverse();
    let curr = rec;

    while (curr && path.length > 0) {
      var _curr;

      curr = (_curr = curr) === null || _curr === void 0 ? void 0 : _curr[path.pop()];
    }

    return curr;
  }
};
const propFunc = (rec, propSpec = '') => {
  if (typeof propSpec === 'function') {
    return propSpec(rec);
  } else if (typeof propSpec === 'string') {
    return propPath(rec, propSpec);
  } else {
    return undefined;
  }
};
;// CONCATENATED MODULE: ./src/group.js
class Group {
  constructor(Container = Array, dict) {
    this.cons = Container;
    this.dict = dict;
  }

  map(func = ([k, v]) => [k, v]) {
    return new Group(this.cons, Object.fromEntries(Object.entries(this.dict).map(func)));
  }

  grap(func) {
    const Cons = this.cons;

    const defaultFunc = ([, v]) => v;

    return new Cons(...Object.entries(this.dict).map(func !== null && func !== void 0 ? func : defaultFunc));
  }

  keys() {
    const Cons = this.cons;
    return new Cons(...Object.keys(this.dict));
  }

  get(key) {
    return this.dict[key];
  }

  getDict() {
    return this.dict;
  }

}
;// CONCATENATED MODULE: ./src/list.js


class List extends Array {
  constructor(...args) {
    super(...args);
  }

  last() {
    return this[this.length - 1];
  }

  orderBy(key) {
    if (key === undefined) {
      throw Error('List.orderBy: key not provided');
    }

    this.sort((prev, next) => {
      const prevVal = propFunc(prev, key),
            nextVal = propFunc(next, key);
      return prevVal > nextVal ? 1 : prevVal < nextVal ? -1 : 0;
    });
    return this;
  }

  grip(key) {
    const Container = this.constructor;
    let group = {};

    if (key === undefined) {
      throw Error('List.orderBy: key not provided');
    }

    for (let i = 0; i < this.length; i++) {
      var _group$label;

      const rec = this[i];
      const label = propFunc(rec, key);
      (_group$label = group[label]) !== null && _group$label !== void 0 ? _group$label : group[label] = new Container();
      group[label].push(rec);
    }

    return new Group(Container, group);
  }

  partition(num) {
    const newList = new this.constructor();

    for (let i = 0; i < this.length; i += num) {
      newList.push(this.slice(i, i + num));
    }

    return newList;
  }

  one(propSpec, val) {
    for (let i = 0; i < this.length; i++) {
      if (propPath(this[i], propSpec) === val) {
        return this[i];
      }
    }

    return undefined;
  }

  all(propSpec, val) {
    const res = new this.constructor();

    for (let i = 0; i < this.length; i++) {
      if (propPath(this[i], propSpec) === val) {
        res.push(this[i]);
      }
    }

    return res;
  }

  mergeFrom(sources, {
    sourceKey,
    targetKey,
    mergeKey,
    mergeFunc
  } = {}) {
    if (!mergeKey && !sourceKey && !targetKey) {
      throw Error('mergeFrom: none of matchKey, partKey, and mergeKey specified');
    }

    if (!mergeFunc) {
      throw Error('mergeFrom: mergeFunc must be specified');
    }

    const targetMap = {};
    const actualTargetKey = targetKey !== null && targetKey !== void 0 ? targetKey : mergeKey;
    const actualSourceKey = sourceKey !== null && sourceKey !== void 0 ? sourceKey : mergeKey;

    for (let targ = this.length - 1; targ >= 0; targ--) {
      var _targetMap$targKey;

      const targElem = this[targ];
      const targKey = propFunc(targElem, actualTargetKey);
      (_targetMap$targKey = targetMap[targKey]) !== null && _targetMap$targKey !== void 0 ? _targetMap$targKey : targetMap[targKey] = targElem;
    }

    for (let sour = sources.length - 1; sour >= 0; sour--) {
      const sourElem = sources[sour];
      const sourKey = propFunc(sourElem, actualSourceKey);
      const targElem = targetMap[sourKey];
      targElem && mergeFunc({
        target: targElem,
        source: sourElem
      });
    }
  }

  insert(rec, index) {
    this.splice(index, 0, rec);
    return this;
  }

  remove(index) {
    this.splice(index, 1);
    return this;
  }

  moveBack(i) {
    if (i > 0) {
      [this[i], this[i - 1]] = [this[i - 1], this[i]];
    }

    return this;
  }

  moveFore(i) {
    if (i < this.length - 1) {
      [this[i], this[i + 1]] = [this[i + 1], this[i]];
    }

    return this;
  }

}
;// CONCATENATED MODULE: ./src/cask.js

class Cask extends List {
  constructor(...args) {
    super(...args);
  }

  unnest(succFunc) {
    if (succFunc === undefined) {
      throw Error('Cask.unnest: succFunc must be defined for expanding childrens');
    }

    const stack = [...this];
    const res = new Cask();

    while (stack.length) {
      const next = stack.shift();
      const succ = succFunc(next);

      if ((succ === null || succ === void 0 ? void 0 : succ.constructor) === Cask && succ.length > 0) {
        stack.unshift(...succ);
      }

      res.push(next);
    }

    return res;
  }

  nest(geneFunc, seekFunc) {
    if (geneFunc === undefined) {
      throw Error('Cask.nest: geneFunc must be defined for partitioning generations');
    }

    if (seekFunc === undefined) {
      throw Error('Cask.nest: seekFunc must be defined for coupling parent and child');
    } // 将列表按照geneFunc指定的方式分代，所得到的结果


    const gens = this.orderBy(geneFunc).grip(geneFunc).grap(); // 在每两代之间进行匹配，seekFunc中规定了匹配的依据及匹配的方法，
    // 由于一个子级元素只能归属于一个父级元素，因此一旦子级元素匹配到
    // 了一个父级元素，就应当立即停止遍历后续的父级元素，故seekFunc
    // 应当返回一个bool值来决定是否停止。
    // 
    // 至于匹配之后要如何进行关联（通常是将子层元素移入父层元素某个列
    // 表属性中），应当在seekFunc中作为一个sideEffect来实现，如果
    // 操作不成功应当抛出异常。

    for (let gene = gens.length - 2; gene >= 0; gene--) {
      const preds = gens[gene];
      const currs = gens[gene + 1];

      for (let curr = currs.length - 1; curr >= 0; curr--) for (let pred = preds.length - 1; pred >= 0; pred--) if (seekFunc(preds[pred], currs[curr])) break;
    } // 返回匹配完成的祖先一代。


    return gens[0];
  }

}
;// CONCATENATED MODULE: ./src/index.js



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// module exports must be returned from runtime so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(981);
/******/ })()
;